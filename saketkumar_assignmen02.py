# -*- coding: utf-8 -*-
"""SaketKumar_Assignmen02

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hzbbNGFWJjKWZ8x090EguO1pyOiBYMuB

# **NAME- SAKET KUMAR**
#**ROLL NO.- 2312res560**
#**COLLEGE NAME- INDIAN INSTITUTE OF TECHNOLOGY, PATNA**
#**BRANCH- BSc(CSDA)**
#**SUBJECT- BO CDA 305: Artificial Intelligence Techniques**
#**Assignment - 02**
#**SEMESTER- 05**
#**YEAR- 03**
---

# **üìò Assignment:** *Pathfinding with Uniform Cost Search (UCS)*
---

#**Objective üéØ:** *To understand and implement Uniform Cost Search (UCS) for solving a pathfinding problem in a weighted graph.*
---

# *UCS will be used to find the **least-cost path** between two cities in a map.*
---

# **Import Libraries**
"""

import heapq

"""## **üìù UCS Implementation**
*The function `uniform_cost_search(graph, start, goal)` finds the least-cost path
using a **priority queue** to always expand the node with the smallest path cost so far.*
"""

def uniform_cost_search(graph, start, goal):
    # Priority Queue stores (cost, path)
    pq = [(0, [start])]
    visited = set()

    while pq:
        (cost, path) = heapq.heappop(pq)
        node = path[-1]

        if node in visited:
            continue
        visited.add(node)

        # Goal reached
        if node == goal:
            return cost, path

        # Expand neighbors
        for neighbor, edge_cost in graph.get(node, []):
            if neighbor not in visited:
                new_cost = cost + edge_cost
                new_path = path + [neighbor]
                heapq.heappush(pq, (new_cost, new_path))

    return float("inf"), []  # If no path exists

"""## ‚úîÔ∏è **Test Case 1: Path from A ‚Üí E**
*We will test UCS on the given graph to find the least-cost path from **A** to **E**.*
"""

graph1 = {
    'A': [('B', 2), ('C', 5)],
    'B': [('A', 2), ('C', 6), ('D', 1)],
    'C': [('A', 5), ('B', 6), ('D', 3), ('E', 8)],
    'D': [('B', 1), ('C', 3), ('E', 4)],
    'E': [('C', 8), ('D', 4)]
}

cost, path = uniform_cost_search(graph1, 'A', 'E')
print("Test Case 1: A ‚Üí E")
print("Minimum Cost:", cost)
print("Path:", path)

"""## ‚úîÔ∏è **Test Case 2: Path from A ‚Üí F**
*Now we add a new city **F** connected to E with cost 2 and test UCS for the path **A ‚Üí F**.*
"""

graph2 = {
    'A': [('B', 2), ('C', 5)],
    'B': [('A', 2), ('C', 6), ('D', 1)],
    'C': [('A', 5), ('B', 6), ('D', 3), ('E', 8)],
    'D': [('B', 1), ('C', 3), ('E', 4)],
    'E': [('C', 8), ('D', 4), ('F', 2)],
    'F': [('E', 2)]
}

cost, path = uniform_cost_search(graph2, 'A', 'F')
print("Test Case 2: A ‚Üí F")
print("Minimum Cost:", cost)
print("Path:", path)

"""## **‚úçÔ∏è Write-up Questions and Answers:**
---

### **(a) How does UCS decide which node to expand next?**

*Uniform Cost Search (UCS) works by always keeping track of the cost of reaching every node from the starting point. It does not just look at how close a city seems or how many steps it takes‚Äîit specifically looks at the **total distance or cost already spent** to reach that node.*

*To manage this, UCS uses a **priority queue** (a special kind of waiting list). In this queue, the path with the **lowest total cost** is always placed at the front, and that path is the one expanded first. For example, if you have two possible ways to continue‚Äîone costing 4 units and another costing 7 units‚ÄîUCS will always expand the path with cost 4 before looking at the one with cost 7.*

*This method ensures that the search never ‚Äújumps ahead‚Äù to a more expensive option without first checking if there is a cheaper path available. In simple terms, UCS expands the cheapest accumulated route step by step, making sure the algorithm always considers the **most cost-effective option first**.*

---

### **(b) Why does UCS always find the optimal path?**

*The strength of UCS lies in the way it explores paths in increasing order of their costs. It does not just guess or randomly pick a path‚Äîit systematically checks every possible path in order of total travel cost, starting from the cheapest one.*

*Because of this, the moment UCS finally expands the **destination city**, it can guarantee that the path taken is the one with the **least overall cost**. That‚Äôs why the first time UCS finds a solution, it is already the **best possible solution**.*

*Another important reason why UCS works correctly is that it assumes all edge costs are **non-negative**. If a road had a negative cost (which is not realistic in normal maps), the algorithm could get confused. But with positive or zero distances, UCS never misses a cheaper alternative, and that‚Äôs why it always returns the **optimal path** without any doubt.*

---

### **(c) What would happen if all edge costs were the same?**

*If every road on the map had exactly the same travel cost‚Äîfor example, if every edge cost was simply 1‚Äîthen UCS would not really need to compare distances anymore. Since all roads are equal, the total cost of a path would just depend on the **number of steps (edges)** it takes, not on the actual distances.*

*In this situation, UCS would behave in the exact same way as **Breadth-First Search (BFS)**. BFS works by exploring all cities one step away, then all cities two steps away, then three steps away, and so on. Since every step costs the same, the path with the smallest number of steps is also the path with the lowest total cost.*

*So, when all edges are equal, UCS and BFS will always give the same result: the **shortest path in terms of the number of edges**. The difference between the two algorithms disappears, because UCS‚Äôs cost-based decision-making is no longer needed.*
"""